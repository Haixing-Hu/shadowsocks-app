'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lezer = require('./lezer.js');

// This file was generated by lezer-generator. You probably shouldn't edit it.
const
  StartTag = 2,
  StartCloseTag = 3,
  MismatchedStartCloseTag = 4,
  missingCloseTag = 32,
  SelfCloserEndTag = 5,
  Element = 9,
  OpenTag = 10,
  SelfClosingTag = 20,
  RawText = 25;

/* Hand-written tokenizers for HTML. */

const selfClosers = {
  area: true, base: true, br: true, col: true, command: true,
  embed: true, frame: true, hr: true, img: true, input: true,
  keygen: true, link: true, meta: true, param: true, source: true,
  track: true, wbr: true, menuitem: true
};

const implicitlyClosed = {
  dd: true, li: true, optgroup: true, option: true, p: true,
  rp: true, rt: true, tbody: true, td: true, tfoot: true,
  th: true, tr: true
};

const closeOnOpen = {
  dd: {dd: true, dt: true},
  dt: {dd: true, dt: true},
  li: {li: true},
  option: {option: true, optgroup: true},
  optgroup: {optgroup: true},
  p: {
    address: true, article: true, aside: true, blockquote: true, dir: true,
    div: true, dl: true, fieldset: true, footer: true, form: true,
    h1: true, h2: true, h3: true, h4: true, h5: true, h6: true,
    header: true, hgroup: true, hr: true, menu: true, nav: true, ol: true,
    p: true, pre: true, section: true, table: true, ul: true
  },
  rp: {rp: true, rt: true},
  rt: {rp: true, rt: true},
  tbody: {tbody: true, tfoot: true},
  td: {td: true, th: true},
  tfoot: {tbody: true},
  th: {td: true, th: true},
  thead: {tbody: true, tfoot: true},
  tr: {tr: true}
};

function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161
}

function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32
}

const lessThan = 60, greaterThan = 62, slash = 47, question = 63, bang = 33;

const tagStartExpr = /^<\s*([\.\-\:\w\xa1-\uffff]+)/;

const elementQuery = [Element];

const tagStart = new lezer.ExternalTokenizer((input, token, stack) => {
  let pos = token.start, first = input.get(pos);
  // End of file, just close anything
  if (first < 0) {
    let contextStart = stack.startOf(elementQuery);
    let match = contextStart < 0 ? null : tagStartExpr.exec(input.read(contextStart, contextStart + 30));
    if (match && implicitlyClosed[match[1].toLowerCase()]) token.accept(missingCloseTag, token.start);
  }
  if (first != lessThan) return
  pos++;
  let next = input.get(pos), close = false;
  if (next == slash) { close = true; pos++; }
  if (next == question || next == bang) return
  let tokEnd = pos;
  while (isSpace(input.get(pos))) pos++;
  let nameStart = pos;
  while (nameChar(input.get(pos))) pos++;
  if (pos > nameStart) {
    let name = input.read(nameStart, pos).toLowerCase();
    let contextStart = stack.startOf(elementQuery);
    let match = contextStart < 0 ? null : tagStartExpr.exec(input.read(contextStart, contextStart + name.length + 10));
    if (match) {
      let contextName = match[1].toLowerCase();
      if (close && name != contextName)
        return implicitlyClosed[contextName] ? token.accept(missingCloseTag, token.start) : token.accept(MismatchedStartCloseTag, tokEnd)
      if (!close && closeOnOpen[contextName] && closeOnOpen[contextName][name])
        return token.accept(missingCloseTag, token.start)
    }
  }
  token.accept(close ? StartCloseTag : StartTag, tokEnd);
}, {contextual: true});

const tagQuery = [OpenTag, SelfClosingTag];

const selfClosed = new lezer.ExternalTokenizer((input, token, stack) => {
  if (input.get(token.start) != greaterThan) return
  let from = stack.startOf(tagQuery);
  let match = from < 0 ? null : tagStartExpr.exec(input.read(from, token.start));
  if (match && selfClosers[match[1].toLowerCase()]) token.accept(SelfCloserEndTag, token.start + 1);
}, {contextual: true});

const openTag = /^<\/?\s*([\.\-\:\w\xa1-\uffff]+)/;

function tagName(tag) {
  let m = openTag.exec(tag);
  return m ? m[1].toLowerCase() : null
}

function attributes(tag) {
  let open = openTag.exec(tag), attrs = {};
  if (open) {
    let attr = /\s*([\.\-\:\w\xa1-\uffff]+)\s*(?:=("[^"]*"|'[^']*'|[^\s=<>"'/]+))?/g, m;
    attr.lastIndex = open.index + open[0].length;
    while (m = attr.exec(tag)) attrs[m[1]] = m[2] || m[1];
  }
  return attrs
}

const stay = {stay: true};

function skip(name) { return token => tagName(token) == name }

// tags: {
//   tag: string,
//   attrs?: ({[attr: string]: string}) => boolean,
//   parser?: Parser,
//   parseNode?: (input: InputStream, start: number) => Tree
// }[]

function resolveContent(tags) {
  let tagMap = null;
  for (let tag of tags) {
    if (!tagMap) tagMap = Object.create(null)
    ;(tagMap[tag.tag] || (tagMap[tag.tag] = [])).push({
      attrs: tag.attrs,
      value: {
        filterEnd: skip(tag.tag),
        parser: tag.parser,
        parseNode: tag.parseNode
      }
    });
  }
  return function(input, stack) {
    let openTag = input.read(stack.ruleStart, stack.pos);
    let name = tagName(openTag), matches, attrs;
    if (!name) return stay
    if (tagMap && (matches = tagMap[name])) {
      for (let match of matches) {
        if (!match.attrs || match.attrs(attrs || (attrs = attributes(openTag)))) return match.value
      }
    }
    if (name == "script" || name == "textarea" || name == "style") return {
      filterEnd: skip(name),
      wrapType: RawText
    }
    return stay
  }
}

const elementContent = resolveContent([]);

function configureTags(parser, tags) {
  return parser.withNested({elementContent: resolveContent(tags)})
}

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = lezer.Parser.deserialize({
  states: "'[OPOTOOOgOWO'#CfSnOTO'#CeOOOS'#Ce'#CeOOOS'#C}'#C}OOOS(3AY(3AYQPOTOOO![OWO'#DOOOOW(3AZ(3AZO!fOWO,59QO!jOTO'#DVOOOS(3A^(3A^OOOO'#DU'#DUO#WOPO,59POOOS,59b,59bOOOW,59c,59cO#bObO1G.lOOOS,59f,59fOgOWO'#CnO#rOpO'#CnOOOS1G.k1G.kO#yObO'#DOO$^ObO7+$WO$kOWO,59YO$oOpO'#DOO$vOpO,59YO$zObO'#DQO%XObO'#ChOOO`(3A[(3A[O%lOYO<<GrO%vOWO1G.tOOO`,59d,59dO%}ObO,59SOOOSAN=^AN=^OOOSAN=hAN=hO&_OWO7+$`O&cO!bO1G.nOOOS<<Gz<<GzO&mO!bO'#DOO&wO!bO7+$YO'OO#tO'#CkO#bObO<<GtO']O#tO'#DSOOO#t(3A](3A]O'jOWO,59VOOO`AN=`AN=`OOO#t,59e,59eOOO`1G.q1G.q",
  stateData: "'r~QPOUSOVSOWSOfSOgSOhTO~sWOZrP~QPOUSOVSOWSOfSOgSORyPSyPpyP~sWOZrXarX~Z`O~QPOUSOVSOWSOfSOgSORyXSyXpyX~RbOScOpdO~sWOTrP]rParPerP~sWOcrP~sWOTrX]rXarXerX^rX~]kOTtPatPetP~ZnO~sWOcrX~cnO~]kOTtXatXetX~sWOTrP]rP^rParPerP~TrOaqOerO~sWOarP~^tOT[a][aa[ae[a~auO~sWO`rPurP~sWO`rXurX~`yOuxO~V{OW{Ow{OuvP~V{OW{Ow{OuvX~u!PO~fgh~",
  goto: "$gzPPPPPPPPP{!RP!XPP!]PP!`P!cPPPPP!i!o#V#]#cPP#i#qP$ZP$^P$a$dXSOQUYXQOQUYTlfjRywRd]XROQUYQUOR^UUVPbnW_VehvUe`kyQhcRvtQjfRojQzxR!OzQYQRaYSTOUTZQYQXPQf`QgbQicQpkQsnQwtR}yRmfR|xR]QR[Q",
  nodeNames: "âš  Document StartTag StartCloseTag StartCloseTag SelfCloserEndTag Text EntityReference CharacterReference Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag CloseTag MismatchedTagName SelfClosingTag SelfCloseEndTag Comment ProcessingInst DoctypeDecl RawText",
  nodeProps: [
    [lezer.NodeProp.top, 1,true]
  ],
  repeatNodeCount: 5,
  tokenData: "Gh!aR!UOX$eXY'rYZ'rZ]$e]^'r^p$epq'rqr$ers(tsv$evw)Uwx%yx!P$e!P!Q0i!Q![$e![!]1u!]!^$e!^!_7`!_!`Dt!`!aEa!a!c$e!c!}1u!}#R$e#R#S1u#S#T$e#T#o1u#o$f$e$f$g%y$g%W$e%W%o1u%o%p$e%p&a1u&a&b$e&b1p1u1p4U$e4U4d1u4d4e$e4e$IS1u$IS$I`$e$I`$Ib1u$Ib$Kh$e$Kh%#t1u%#t&/x$e&/x&Et1u&Et&FV$e&FV;'S1u;'S;:jE|;:j?&r$e?&r?Ah1u?Ah?BY$e?BY?Mn1u?Mn~$e!R$ncUP``wpOX$eXZ%yZ]$e]^%y^p$epq%yqr$ers&dsv$evw'Qwx%yx!P$e!P!Q%y!Q!^$e!^!_&r!_!a%y!a$f$e$f$g%y$g~$eq&QUUPwpOr%yrs&dsv%yw!^%y!^!_&r!_~%yP&iRUPOv&dw!^&d!_~&dp&wRwpOr&rsv&rw~&r`'VX``OX'QZ]'Q^p'Qqr'Qsw'Qx!P'Q!Q!^'Q!a$f'Q$g~'Q!a'{]UPwpsnOX%yXY'rYZ'rZ]%y]^'r^p%ypq'rqr%yrs&dsv%yw!^%y!^!_&r!_~%y!T({Ru!SUPOv&dw!^&d!_~&d!R)Zb``OX*cXZ+pZ]*c]^+p^p*cqr*crs+pst,{tw*cwx+px!P*c!P!Q+p!Q!]*c!]!^'Q!^!a+p!a$f*c$f$g+p$g~*c!R*hb``OX*cXZ+pZ]*c]^+p^p*cqr*crs+pst'Qtw*cwx+px!P*c!P!Q+p!Q!]*c!]!^,X!^!a+p!a$f*c$f$g+p$g~*cq+sTOp+pqs+pt!]+p!]!^,S!^~+pq,XOVq!R,`XVq``OX'QZ]'Q^p'Qqr'Qsw'Qx!P'Q!Q!^'Q!a$f'Q$g~'Q!R-Qa``OX.VXZ/aZ].V]^/a^p.Vqr.Vrs/asw.Vwx/ax!P.V!P!Q/a!Q!].V!]!^'Q!^!a/a!a$f.V$f$g/a$g~.V!R.[a``OX.VXZ/aZ].V]^/a^p.Vqr.Vrs/asw.Vwx/ax!P.V!P!Q/a!Q!].V!]!^/u!^!a/a!a$f.V$f$g/a$g~.Vq/dSOp/aq!]/a!]!^/p!^~/aq/uOWq!R/|XWq``OX'QZ]'Q^p'Qqr'Qsw'Qx!P'Q!Q!^'Q!a$f'Q$g~'Qw0pWUPwpOr%yrs&dsv%yw!^%y!^!_&r!_!`%y!`!a1Y!a~%yw1cUeUUPwpOr%yrs&dsv%yw!^%y!^!_&r!_~%y!a2U!Y]ScWZQUP``wpOX$eXZ%yZ]$e]^%y^p$epq%yqr$ers&dsv$evw'Qwx%yx}$e}!O1u!O!P1u!P!Q%y!Q![1u![!]1u!]!^$e!^!_&r!_!a%y!a!c$e!c!}1u!}#R$e#R#S1u#S#T$e#T#o1u#o$f$e$f$g%y$g$}$e$}%O1u%O%W$e%W%o1u%o%p$e%p&a1u&a&b$e&b1p1u1p4U1u4U4d1u4d4e$e4e$IS1u$IS$I`$e$I`$Ib1u$Ib$Je$e$Je$Jg1u$Jg$Kh$e$Kh%#t1u%#t&/x$e&/x&Et1u&Et&FV$e&FV;'S1u;'S;:j5t;:j?&r$e?&r?Ah1u?Ah?BY$e?BY?Mn1u?Mn~$e!a5}eUP``wpOX$eXZ%yZ]$e]^%y^p$epq%yqr$ers&dsv$evw'Qwx%yx!P$e!P!Q%y!Q!^$e!^!_&r!_!a%y!a$f$e$f$g%y$g;=`$e;=`<%l1u<%l~$eq7eUwpOq&rqr7wsv&rw!a&r!a!bBo!b~&rq7|XwpOr&rsv&rw}&r}!O8i!O!f&r!f!g<W!g#W&r#W#X@R#X~&rq8nTwpOr&rsv&rw}&r}!O8}!O~&rq9SVwpOr8}rs9isv8}vw9iw}8}}!O:j!O~8}P9lRO}9i}!O9u!O~9iP9xRO}9i}!O:R!O~9iP:UTO}9i}!O:R!O!`9i!`!a:e!a~9iP:jOfPq:oVwpOr8}rs9isv8}vw9iw}8}}!O;U!O~8}q;ZXwpOr8}rs9isv8}vw9iw}8}}!O;U!O!`8}!`!a;v!a~8}q;}RwpfPOr&rsv&rw~&rq<]TwpOr&rsv&rw!q&r!q!r<l!r~&rq<qTwpOr&rsv&rw!e&r!e!f=Q!f~&rq=VTwpOr&rsv&rw!v&r!v!w=f!w~&rq=kTwpOr&rsv&rw!{&r!{!|=z!|~&rq>PTwpOr&rsv&rw!r&r!r!s>`!s~&rq>eTwpOr&rsv&rw!g&r!g!h>t!h~&rq>yVwpOr>trs?`sv>tvw?`w!`>t!`!a?q!a~>tP?cRO!`?`!`!a?l!a~?`P?qOhPq?xRwphPOr&rsv&rw~&rq@WTwpOr&rsv&rw#c&r#c#d@g#d~&rq@lTwpOr&rsv&rw#V&r#V#W@{#W~&rqAQTwpOr&rsv&rw#h&r#h#iAa#i~&rqAfTwpOr&rsv&rw#m&r#m#nAu#n~&rqAzTwpOr&rsv&rw#d&r#d#eBZ#e~&rqB`TwpOr&rsv&rw#X&r#X#Y>t#Y~&rqBtVwpOrBorsCZsvBovwCZw!aBo!a!bCx!b~BoPC^RO!aCZ!a!bCg!b~CZPCjRO!`CZ!`!aCs!a~CZPCxOgPqC}VwpOrBorsCZsvBovwCZw!`Bo!`!aDd!a~BoqDkRwpgPOr&rsv&rw~&ruD}U^SUPwpOr%yrs&dsv%yw!^%y!^!_&r!_~%ywEjUaUUPwpOr%yrs&dsv%yw!^%y!^!_&r!_~%y!aFVeUP``wpOX$eXZ%yZ]$e]^%y^p$epq%yqr$ers&dsv$evw'Qwx%yx!P$e!P!Q%y!Q!^$e!^!_&r!_!a%y!a$f$e$f$g%y$g;=`$e;=`<%l1u<%l~$e",
  tokenizers: [tagStart, selfClosed, 0, 1, 2, 3, 4, 5],
  nested: [["elementContent", elementContent,"&k~RP!^!_U~XP!P!Q[~_dXY!mYZ!m]^!mpq!m![!]$O!c!}$O#R#S$O#T#o$O%W%o$O%p&a$O&b1p$O4U4d$O4e$IS$O$I`$Ib$O$Kh%#t$O&/x&Et$O&FV;'S$O;'S;:j&e?&r?Ah$O?BY?Mn$O~!pdXY!mYZ!m]^!mpq!m![!]$O!c!}$O#R#S$O#T#o$O%W%o$O%p&a$O&b1p$O4U4d$O4e$IS$O$I`$Ib$O$Kh%#t$O&/x&Et$O&FV;'S$O;'S;:j&e?&r?Ah$O?BY?Mn$O~$RkXY%vYZ%v]^%vpq%v}!O$O!O!P$O!Q![$O![!]$O!`!a&Y!c!}$O#R#S$O#T#o$O$}%O$O%W%o$O%p&a$O&b1p$O1p4U$O4U4d$O4e$IS$O$I`$Ib$O$Je$Jg$O$Kh%#t$O&/x&Et$O&FV;'S$O;'S;:j&_?&r?Ah$O?BY?Mn$O~%yTXY%vYZ%v]^%vpq%v!`!a&Y~&_Oo~~&bP;=`<%l$O~&hP;=`<%l$O", 40]],
  specializeTable: 0,
  tokenPrec: 306
});

function configureHTML(tags) { return configureTags(parser, tags) }

exports.configureHTML = configureHTML;
exports.parser = parser;
